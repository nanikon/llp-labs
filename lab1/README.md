 # Лабораторная работа №1
 
## Цель
Модуль осуществляющий хранение (выборку, размещение, гранулярное обновление) данных в одном файле в форме документного дерева.
## Задачи
1. Спроектировать структуры данных для представления информации в оперативной памяти
   1. Для порции данных, состоящий из элементов определённого рода (см форму данных),
   поддержать тривиальные значения по меньшей мере следующих типов: цетырёхбайтовые
   целые числа и числа с плавающей точкой, текстовые строки произвольной длины, булевские
   значения
   1. Для информации о запросе
1. Спроектировать представление данных с учетом схемы для файла данных и реализовать базовые
   операции для работы с ним:
   1. Операции над схемой данных (создание и удаление элементов схемы)
   2. Базовые операции над элементами данных в соответствии с текущим состоянием схемы (над
   узлами или записями заданного вида)
      1. Вставка элемента данных
      1. Перечисление элементов данных
      1. Обновление элемента данных
      1. Удаление элемента данных
1. Используя в сигнатурах только структуры данных из п.1, реализовать публичный интерфейс со
   следующими операциями над файлом данных:
   1. Добавление, удаление и получение информации о элементах схемы данных, размещаемых в
   файле данных, на уровне, соответствующем виду узлов или записей
   1. Добавление нового элемента данных определённого вида
   1. Выборка набора элементов данных с учётом заданных условий и отношений со смежными
   элементами данных (по свойствам/полями/атрибутам и логическим связям соответственно)
   1. Обновление элементов данных, соответствующих заданным условиям
   1. Удаление элементов данных, соответствующих заданным условиям
4. Реализовать тестовую программу для демонстрации работоспособности решения
   1. Параметры для всех операций задаются посредством формирования соответствующих структур
   данных
   1. Показать, что при выполнении операций, результат выполнения которых не отражает
   отношения между элементами данных, потребление оперативной памяти стремится к O(1)
   независимо от общего объёма фактического затрагиваемых данных
   1. Показать, что операция вставки выполняется за O(1) независимо от размера данных,
   представленных в файле
   1. Показать, что операция выборки без учёта отношений (но с опциональными условиями)
   выполняется за O(n), где n – количество представленных элементов данных выбираемого вида
   1. Показать, что операции обновления и удаления элемента данных выполняются не более чем за
   O(n*m) > t  O(n+m), где n – количество представленных элементов данных обрабатываемого
   вида, m – количество фактически затронутых элементов данных
   1. Показать, что размер файла данных всегда пропорционален количеству фактически
   размещённых элементов данных
   1. Показать работоспособность решения под управлением ОС семейств Windows и *NIX
## Использование
### Windows
Требования:
* CMake 3.22.1+
* MinGW for x86_64 12.2.0+ (включая x86_64-w64-mingw32-gcc, x86_64-w64-mingw32-g++, ar, mingw32-make)

Установка системных переменных:
* PATH ({your_path} через обратный слэш):
  * {your_path}\CMakein
  * {your_path}\mingw64\bin
* MINGW_W64_BIN_DIR ({your_path} через прямой слэш):
   * {your_path}/mingw64/bin 

Сборка:

`build.bat`

Запуск unit-тестов:

`build\main.exe u`

Запуск нагрузочных тестов:

`build\main.exe s`
### Linux
Требования:
* CMake 3.22.1+
* GNU Make 4.3+
* g++ 11.3.0+

Сборка:

`./build.sh`

Запуск unit-тестов:

`./build/main u`

Запуск нагрузочных тестов:

`./build/main s`
## Устройство модуля

### File

Самый низкий уровень - содержит в себе функции для непосредственной записи в файл (чтении из файла) буферов указанной длины:

`
size_t write_buffer_to_file(int32_t fd, size_t offset, const void* buffer, size_t elem_size, size_t count)
size_t read_buffer_from_file(int32_t fd, size_t offset, void* buffer, size_t elem_size, size_t count)
`

Или же нуль-терминированных (в оперативной памяти, а в файле записанных как длина строки + она сама) строк:

`
size_t write_null_term_str_to_file(int32_t fd, size_t offset, const char* str)
size_t read_null_term_str_from_file(int32_t fd, size_t offset, const char** buffer)
`

Также в нем имеются функции открытия/закрытия файла, получения его размера и копирования строки в кучу и возвращения ссылки на неё в переданный указатель. Она не совсем относится к работе с файлом, но  используется во всех блоках более высоких уровней, поэтому лежит здесь.

`
int32_t open_file(const char* filename)
void close_file(int32_t fd)
size_t get_file_len(const int32_t fd)
void copy_str_to_heap(const char** dest, char* source)
`

### Structs

Содержит в себе описания используемых в модуле структур, а также функции по их записи в файл (чтении из него) -полной или частичной - и освобождении, а также специфичные для каждой структуры функции. Можно поделить на четыре части: блоки, файловый заголовок, схемы и ноды.
* блоки

`
struct block {
    size_t next;
    size_t prev;
    size_t size;
};
`

Описывает пустое пространство в файле. Связаны в двухсвязный список для быстрого создания\удаления и относительно быстрого поиска.
* файловый заголовок

`struct tree_header {
    // Смещение первого узла дерева относительно начала файла
    size_t first_node;
    // Смещение первой схемы узла относительно начала файла
    size_t first_schema;
    // Смещение последней схемы узла относительно начала файла
    size_t last_schema;
    // Смещение первого свободного блока относительно начала файла
    size_t first_free_block;
    // Конец файла - сюда идет запись если в нем самом нет пустого места
    size_t end_file;
};

struct file_descriptor {
    int32_t fd;
    struct tree_header* header;
};`

Является идентификатором файла, хранит необходимую информацию для записи в него (поэтому его необходимо передавать в любую функцию, которая выполняет какие-либо действия с файлом), а также метаданные. 
* схемы

`
enum value_type {
    INT,
    DOUBLE,
    BOOL,
    STRING
};

struct attribute_schema { 
    enum value_type type;
    const char* name;
};

struct schema {
    size_t offset; 
    size_t elem_size; // длина блока в файле в котором записана схема - может быть больше фактической длины
    size_t next;
    size_t prev;
    size_t count; // кол-во вершин с этой схемой - нужно для удаления, точнее для его запрещения
    const char* name; // нуль-терминированная строка
    std::vector<struct attribute_schema*>* attributes;
}; 
`

Cхема определяет формат, в котором могут хранитя данные в ноде. Имеет имя и список из схем аттрибутов, каждый из которых, в свою очередь, имеет имя и тип значения.
* ноды

`
union data {
    int int_value;
    double double_value;
    const char* string_value;
    bool bool_value;
};

struct attribute {
    struct attribute_schema* schema;
    union data value; 
};

struct node {
    size_t offset;
    size_t elem_size;
    struct schema* schema;

    size_t parent;
    size_t first_child;
    size_t prev_sibiling;
    size_t next_sibiling;

    std::vector<struct attribute*>* attributes;
};
`

Непосредственно сам элемент данных. Содержит в себе ссылку на схему, ссылки на окружающе его ноды (об этом подробнее в разделе "Хранения данных в файле и алгоритмы") и сами данные в формате, соответствующем схеме.

### API

Для работы необходимо подключить заголовочный файл `api.h` (из пакета api). В нем собрано все необходимое для работы с модулем, и логически он делится на четыре блока (которые реализуются в соответствующих cpp файлах):
* блок непосредственной работы с файлом
В нем содержатся две функции - для открытия и закрытия файла.

Для начала работы необоходимо вызвать функцию открытия (которая при необходимости создает и инициализирует файл нужными метаданными):

`struct file_descriptor* open_file_db(const char* filename)`

В результате её работы получаем указатель на заголовок файла, описанный в предыдущем разделе. 

При окончании работы следует вызвать функцию следующую функцию, которая запишет обновленный заголовк в файл, закроет файл и очистит оперативную память от заголовка. После неё указатель на заголовк файла является недействительным.

`void close_file_db(struct file_descriptor* ptr)`
* блок работы со схемой представления данных
Чтобы создать новую схему данных, воспользуйтесь функцией:

`struct schema* create_schema(struct file_descriptor* ptr, char* name, std::vector<struct attribute_schema*>* attributes)`

В результате получим представление схемы в оператиной памяти для дальнейшего использования. В функцию создания надо передать указатель на заголовок файла, чтобы записать её в определенный файл, имя схемы (исключительно для вашего удобства) и список схем аттрибутов, каждый из которых можно создать функцией:

`struct attribute_schema* create_attribute(enum value_type type, char* name)`

Куда надо передать имя аттрибута и его тип - `INT`, `DOUBLE`, `BOOL` или `STRING`

Для удаления схемы необходимо воспользоваться функцией:

`enum schema_delete_operation_status delete_schema(struct file_descriptor* ptr, struct schema* schema)`

Возвращаемое значение сигнализирует о успешности ужаления - если схема не найдена в файле, или если в файле есть ноды по этой схеме, удалить её нельзя.
При успешном удалении функция полностью очищает занимаемое схемой место, и указатель на неё становится недействительным.

Чтобы просмотреть все схемы файла, следует воспользоваться итератором:

`
typedef struct Schema_Iter {
    struct schema* schema;
    struct file_descriptor* ptr;
    bool is_valid = true;

    Schema_Iter(struct file_descriptor* ptr) : ptr(ptr) {
        this->schema = read_first_schema(ptr);
        if (this->schema == NULL) {
            is_valid = false;
        }
    }

    bool next();
    struct schema* operator*();
    void free();
} Schema_Iter;
`

Получить его можно с помощью функции:

`
Schema_Iter read_schemas(struct file_descriptor* ptr)
`
* блок для манипулирования данными
* блок поиска данных

## Хранение данных в файле

## Тестирование

## Выводы
В ходе выполнения данной лабораторной работы я впервые спроектировала и написала такой большой по объему и сложности программный модуль на языке С/С++, познакомилась с инструментов сборки cmake и особенностями кросс-платформенной сборки, а также с утилитой поиска утечек памяти valgrind.